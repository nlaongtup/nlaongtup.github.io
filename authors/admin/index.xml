<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nuttapong La-ongtup</title>
    <link>https://nlaongtup.github.io/authors/admin/</link>
      <atom:link href="https://nlaongtup.github.io/authors/admin/index.xml" rel="self" type="application/rss+xml" />
    <description>Nuttapong La-ongtup</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 19 Apr 2021 00:01:00 +0000</lastBuildDate>
    <image>
      <url>https://nlaongtup.github.io/img/icon-192.png</url>
      <title>Nuttapong La-ongtup</title>
      <link>https://nlaongtup.github.io/authors/admin/</link>
    </image>
    
    <item>
      <title>AWS Rekognition API for Celebrity Recognition</title>
      <link>https://nlaongtup.github.io/post/aws-recognition-api/</link>
      <pubDate>Mon, 19 Apr 2021 00:01:00 +0000</pubDate>
      <guid>https://nlaongtup.github.io/post/aws-recognition-api/</guid>
      <description>

&lt;h3 id=&#34;prerequisite&#34;&gt;Prerequisite&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Setup IAM user on AWS, see &lt;a href=&#34;https://docs.aws.amazon.com/rekognition/latest/dg/setting-up.html#setting-up-iam&#34; target=&#34;_blank&#34;&gt;create an IAM user&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install AWS CLI and SDKs eg. boto3, see &lt;a href=&#34;https://docs.aws.amazon.com/rekognition/latest/dg/setup-awscli-sdk.html&#34; target=&#34;_blank&#34;&gt;set up the AWS CLI and AWS SDKs&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import boto3
import json

from six.moves.urllib.request import urlopen
from six import BytesIO

import numpy as np
from PIL import Image
from PIL import ImageColor
from PIL import ImageDraw, ExifTags, ImageColor
from PIL import ImageFont
from PIL import ImageOps

import tempfile
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;define-utility-function&#34;&gt;Define utility function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def recognize_celebrities(photo):

    client=boto3.client(&#39;rekognition&#39;)

    with open(photo, &#39;rb&#39;) as image:
        response = client.recognize_celebrities(Image={&#39;Bytes&#39;: image.read()})

    return response

def download_image(img_url):
    open_image = urlopen(img_url)
    image_data = open_image.read()
    image_data = BytesIO(image_data)
    pil_image = Image.open(image_data)
    imgWidth, imgHeight = pil_image.size
    pil_image = ImageOps.fit(pil_image, (imgWidth,imgHeight), Image.ANTIALIAS)
    pil_image_rgb = pil_image.convert(&amp;quot;RGB&amp;quot;)
    pil_image_rgb.save(&amp;quot;celeb.jpg&amp;quot;, format=&amp;quot;JPEG&amp;quot;, quality=90)

def display_image(image):
    fig = plt.figure(figsize=(15, 15))
    plt.grid(False)
    plt.imshow(image)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;download-test-image&#34;&gt;Download test image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;download_image(&amp;quot;https://upload.wikimedia.org/wikipedia/commons/2/2c/Lady_Gaga_interview_2016.jpg&amp;quot;)
detect_img_path=&#39;celeb.jpg&#39;
image = Image.open(detect_img_path)
display_image(image)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test image:
&lt;img src=&#34;./aws-reg-01.png&#34; alt=&#34;jpg&#34; title=&#34;test image&#34; /&gt;
Why Lady Gaga? because she is so talented, brilliant, incredible, amazing, show stopping, spectacular, never the same, totally unique, completely not ever been done before, unafraid to reference or not reference, put it in a blender, shit on it, vomit on it, eat it, give birth to it.
&lt;img src=&#34;./aws-reg-02.gif&#34; alt=&#34;jpg&#34; title=&#34;Lady Gaga&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OK, joking aside. Let&amp;rsquo;s continue :3&lt;/p&gt;

&lt;h3 id=&#34;invoke-the-model-via-aws-rekognition-api&#34;&gt;Invoke the model via AWS Rekognition API&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;detect_img_path=&#39;celeb.jpg&#39;
response = recognize_celebrities(detect_img_path)
json_response = json.dumps(response, indent=4)
print(json_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we will receive a JSON formatted response like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;{
    &amp;quot;CelebrityFaces&amp;quot;: [
        {
            &amp;quot;Urls&amp;quot;: [
                &amp;quot;www.imdb.com/name/nm3078932&amp;quot;
            ],
            &amp;quot;Name&amp;quot;: &amp;quot;Lady Gaga&amp;quot;,
            &amp;quot;Id&amp;quot;: &amp;quot;4Fn1Te4k&amp;quot;,
            &amp;quot;Face&amp;quot;: {
                &amp;quot;BoundingBox&amp;quot;: {
                    &amp;quot;Width&amp;quot;: 0.4975884258747101,
                    &amp;quot;Height&amp;quot;: 0.3868750035762787,
                    &amp;quot;Left&amp;quot;: 0.18006430566310883,
                    &amp;quot;Top&amp;quot;: 0.18000000715255737
                },
                &amp;quot;Confidence&amp;quot;: 99.99113464355469,
                &amp;quot;Landmarks&amp;quot;: [
                    {
                        &amp;quot;Type&amp;quot;: &amp;quot;eyeLeft&amp;quot;,
                        &amp;quot;X&amp;quot;: 0.3336140513420105,
                        &amp;quot;Y&amp;quot;: 0.33852386474609375
                    },
                    {
                        &amp;quot;Type&amp;quot;: &amp;quot;eyeRight&amp;quot;,
                        &amp;quot;X&amp;quot;: 0.48979300260543823,
                        &amp;quot;Y&amp;quot;: 0.33140549063682556
                    },
                    {
                        &amp;quot;Type&amp;quot;: &amp;quot;nose&amp;quot;,
                        &amp;quot;X&amp;quot;: 0.36879873275756836,
                        &amp;quot;Y&amp;quot;: 0.4117993116378784
                    },
                    {
                        &amp;quot;Type&amp;quot;: &amp;quot;mouthLeft&amp;quot;,
                        &amp;quot;X&amp;quot;: 0.357170045375824,
                        &amp;quot;Y&amp;quot;: 0.46853089332580566
                    },
                    {
                        &amp;quot;Type&amp;quot;: &amp;quot;mouthRight&amp;quot;,
                        &amp;quot;X&amp;quot;: 0.4952928423881531,
                        &amp;quot;Y&amp;quot;: 0.4677777886390686
                    }
                ],
                &amp;quot;Pose&amp;quot;: {
                    &amp;quot;Roll&amp;quot;: -2.1802918910980225,
                    &amp;quot;Yaw&amp;quot;: -24.470903396606445,
                    &amp;quot;Pitch&amp;quot;: 0.10077361017465591
                },
                &amp;quot;Quality&amp;quot;: {
                    &amp;quot;Brightness&amp;quot;: 80.43765258789062,
                    &amp;quot;Sharpness&amp;quot;: 96.63640594482422
                }
            },
            &amp;quot;MatchConfidence&amp;quot;: 72.0
        }
    ],
    &amp;quot;UnrecognizedFaces&amp;quot;: [],
    &amp;quot;OrientationCorrection&amp;quot;: &amp;quot;ROTATE_0&amp;quot;,
    &amp;quot;ResponseMetadata&amp;quot;: {
        &amp;quot;RequestId&amp;quot;: &amp;quot;36aabe95-3fe3-40ff-85e2-e637544b0564&amp;quot;,
        &amp;quot;HTTPStatusCode&amp;quot;: 200,
        &amp;quot;HTTPHeaders&amp;quot;: {
            &amp;quot;content-type&amp;quot;: &amp;quot;application/x-amz-json-1.1&amp;quot;,
            &amp;quot;date&amp;quot;: &amp;quot;Mon, 19 Apr 2021 09:56:57 GMT&amp;quot;,
            &amp;quot;x-amzn-requestid&amp;quot;: &amp;quot;36aabe95-3fe3-40ff-85e2-e637544b0564&amp;quot;,
            &amp;quot;content-length&amp;quot;: &amp;quot;850&amp;quot;,
            &amp;quot;connection&amp;quot;: &amp;quot;keep-alive&amp;quot;
        },
        &amp;quot;RetryAttempts&amp;quot;: 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-the-json-response&#34;&gt;Check the JSON response&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for celebrity in response[&#39;CelebrityFaces&#39;]:
    print (&#39;Name: &#39; + celebrity[&#39;Name&#39;])
    print (&#39;Match Confidence: &#39; + &#39;{:.2f}&#39;.format(celebrity[&#39;MatchConfidence&#39;]))
    print (&#39;Info&#39;)
    for url in celebrity[&#39;Urls&#39;]:
        print (&#39;   &#39; + url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can see the result more clearly. The result include Match Confidence which indicate how much the model is confidence that the recognized face is the celebrity. The result also the info website.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Name: Lady Gaga
Match Confidence: 72.00
Info
   www.imdb.com/name/nm3078932
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;draw-a-bounding-box-on-the-image&#34;&gt;Draw a bounding box on the image&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def draw_boxes(image_path, response):

    image = Image.open(image_path)
    draw = ImageDraw.Draw(image)
    imgWidth, imgHeight = image.size

    color = &#39;#00d400&#39;
    font = ImageFont.truetype(&amp;quot;/usr/share/fonts/truetype/lato/Lato-Regular.ttf&amp;quot;,70)

    for celebFace in response[&#39;CelebrityFaces&#39;]:

        faceDetail = celebFace[&amp;quot;Face&amp;quot;]
        box = faceDetail[&#39;BoundingBox&#39;]
        left = imgWidth * box[&#39;Left&#39;]
        top = imgHeight * box[&#39;Top&#39;]
        width = imgWidth * box[&#39;Width&#39;]
        height = imgHeight * box[&#39;Height&#39;]

        points = (
            (left,top),
            (left + width, top),
            (left + width, top + height),
            (left , top + height),
            (left, top)

        )

        display_str = celebFace[&#39;Name&#39;] +&amp;quot; &amp;quot;+ str(celebFace[&#39;MatchConfidence&#39;])+&amp;quot;%&amp;quot;
        text_width, text_height = font.getsize(display_str)
        margin = np.ceil(0.05 * text_height)
        text_bottom = top

        draw.line(points, fill=color, width=5)
        draw.rectangle([(left, text_bottom - text_height - 2 * margin),
                        (left + text_width, text_bottom)],
                       fill=color)

        draw.text((left + margin, text_bottom - text_height - margin),
          display_str,
          fill=&amp;quot;black&amp;quot;,
          font=font)

    return image
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;detect_img = &amp;quot;celeb.jpg&amp;quot;
draw_image = draw_boxes(detect_img, response)
if display:
    display_image(draw_image)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./aws-reg-03.png&#34; alt=&#34;jpg&#34; title=&#34;test image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Paw up little monster, we did it!!!
Now let&amp;rsquo;s try with other image shall we?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;download_image(&amp;quot;https://pbs.twimg.com/media/BhxWutnCEAAtEQ6?format=jpg&amp;quot;)
detect_img_path=&#39;celeb.jpg&#39;
response = recognize_celebrities(detect_img_path)

for celebrity in response[&#39;CelebrityFaces&#39;]:

    print (&#39;Name: &#39; + celebrity[&#39;Name&#39;])
    print (&#39;Match Confidence: &#39; + &#39;{:.2f}&#39;.format(celebrity[&#39;MatchConfidence&#39;]))
    print (&#39;Info&#39;)
    for url in celebrity[&#39;Urls&#39;]:
        print (&#39;   &#39; + url)

detect_img = &amp;quot;celeb.jpg&amp;quot;
draw_image = draw_boxes(detect_img, response)
if display:
    display_image(draw_image)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Name: Bradley Cooper
Match Confidence: 100.00
Info
   www.imdb.com/name/nm0177896
Name: Ellen DeGeneres
Match Confidence: 100.00
Info
   www.imdb.com/name/nm0001122
Name: Jennifer Lawrence
Match Confidence: 67.00
Info
   www.imdb.com/name/nm2225369
Name: Wayne Wonder
Match Confidence: 69.00
Info
   www.imdb.com/name/nm0938872
Name: Patrik Antonius
Match Confidence: 67.00
Info
Name: Kevin Spacey
Match Confidence: 60.00
Info
   www.imdb.com/name/nm0000228
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./aws-reg-04.png&#34; alt=&#34;jpg&#34; title=&#34;test image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Impressive! imagine how useful of this API on digital marketing, advertising, and media industry. Stay tuned for interesting Machine Learning story.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Keras-TensorFlow Implementation of Grad-CAM Class Activation Visualization</title>
      <link>https://nlaongtup.github.io/post/tensorflow-keras/</link>
      <pubDate>Thu, 15 Apr 2021 00:02:00 +0000</pubDate>
      <guid>https://nlaongtup.github.io/post/tensorflow-keras/</guid>
      <description>

&lt;p&gt;Have you ever wonder where convolutional neural network model is looking when predict a certain class? This is what Grad-CAM is for.&lt;/p&gt;

&lt;p&gt;This implementation is adapted from &lt;a href=&#34;https://keras.io/examples/vision/grad_cam/&#34; target=&#34;_blank&#34;&gt;Grad-CAM class activation visualization&lt;/a&gt; by &lt;a href=&#34;https://twitter.com/fchollet&#34; target=&#34;_blank&#34;&gt;fchollet&lt;/a&gt; and the technique Grad-CAM was developed by  Ramprasaath R. Selvaraju. et al.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./gradcam_2.jpg&#34; alt=&#34;jpg&#34; title=&#34;An illustration of Grad-CAM technique&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For full details about Grad-CAM technique, refer to this publication: &lt;a href=&#34;https://arxiv.org/abs/1610.02391&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/1610.02391&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;related-tools&#34;&gt;Related Tools&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Keras-TensorFlow&lt;/li&gt;
&lt;li&gt;Xception model, pre-trained using ImageNet dataset (thanks to &lt;a href=&#34;https://twitter.com/fchollet&#34; target=&#34;_blank&#34;&gt;fchollet&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Grad-CAM technique generate a heatmap where the significant features of predicted class are located, a class activation visualization so to speak.&lt;/p&gt;

&lt;h4 id=&#34;setup&#34;&gt;Setup&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import tensorflow as tf
from tensorflow import keras
from IPython.display import Image, display
import matplotlib.pyplot as plt
import matplotlib.cm as cm

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;configure-xception-model-pre-trained-with-imagenet-dataset&#34;&gt;Configure Xception model pre-trained with ImageNet dataset&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model_builder = keras.applications.xception.Xception
img_size = (299, 299)
preprocess_input = keras.applications.xception.preprocess_input
decode_predictions = keras.applications.xception.decode_predictions

model = model_builder(weights=&amp;quot;imagenet&amp;quot;)
model.layers[-1].activation = None

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-grad-cam-algorithm-to-generate-the-grad-cam-heatmap-and-create-a-superimposed-visualization&#34;&gt;The Grad-CAM algorithm to generate the Grad-CAM heatmap and create a superimposed visualization&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get_img_array(img_path, size):
    img = keras.preprocessing.image.load_img(img_path, target_size=size)
    array = keras.preprocessing.image.img_to_array(img)
    array = np.expand_dims(array, axis=0)
    return array


def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )
    with tf.GradientTape() as tape:
        last_conv_layer_output, preds = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(preds[0])
        class_channel = preds[:, pred_index]
    grads = tape.gradient(class_channel, last_conv_layer_output)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

    last_conv_layer_output = last_conv_layer_output[0]
    heatmap = last_conv_layer_output @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)

    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap.numpy()

    def save_and_display_gradcam(img_path, heatmap, cam_path=&amp;quot;cam.jpg&amp;quot;, alpha=0.4):

        img = keras.preprocessing.image.load_img(img_path)
        img = keras.preprocessing.image.img_to_array(img)

        heatmap = np.uint8(255 * heatmap)
        jet = cm.get_cmap(&amp;quot;jet&amp;quot;)

        jet_colors = jet(np.arange(256))[:, :3]
        jet_heatmap = jet_colors[heatmap]

        jet_heatmap = keras.preprocessing.image.array_to_img(jet_heatmap)
        jet_heatmap = jet_heatmap.resize((img.shape[1], img.shape[0]))
        jet_heatmap = keras.preprocessing.image.img_to_array(jet_heatmap)

        superimposed_img = jet_heatmap * alpha + img
        superimposed_img = keras.preprocessing.image.array_to_img(superimposed_img)

        superimposed_img.save(cam_path)
        display(Image(cam_path))

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;prepare-a-test-image&#34;&gt;Prepare a test image&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
img_path = keras.utils.get_file(
    &amp;quot;test_image_01.jpg&amp;quot;, &amp;quot;https://i.imgur.com/w4bkT7P.jpg&amp;quot;
)
img_array = preprocess_input(get_img_array(img_path, size=img_size))

display(Image(img_path))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test image:
&lt;img src=&#34;./gradcam_3.jpg&#34; alt=&#34;jpg&#34; title=&#34;test image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;predict-a-class-from-the-test-image&#34;&gt;Predict a class from the test image&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;preds = model.predict(img_array)
print(&amp;quot;Predicted:&amp;quot;, decode_predictions(preds, top=1)[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;predicted-output&#34;&gt;Predicted output&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Predicted: [(&#39;n02412080&#39;, &#39;ram&#39;, 9.088227)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;generate-an-activation-heatmap-of-the-predicted-class&#34;&gt;Generate an Activation Heatmap of the Predicted Class&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;save_and_display_gradcam(img_path, heatmap)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class activation heatmap over the original image:
&lt;img src=&#34;./gradcam_4.jpg&#34; alt=&#34;jpg&#34; title=&#34;test image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Voil√†! That red color region is where the &amp;ldquo;ram&amp;rdquo; feature located. Now we finally know what Convolutional Neural Network was looking at when they predict the class &amp;ldquo;ram&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;What is &amp;ldquo;ram&amp;rdquo; anyway. I&amp;rsquo;ve always thought it&amp;rsquo;s a &amp;ldquo;sheep&amp;rdquo; that I took a selfie with!!! XD&lt;/p&gt;

&lt;p&gt;By the way, stay tuned! next time I will implement more about popular computer vision techniques like&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Transfer Learning&lt;/li&gt;
&lt;li&gt;Object Detection&lt;/li&gt;
&lt;li&gt;Image segmentation etc.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Using SciPy and LAMMP for Kinetic Monte Carlo Platform</title>
      <link>https://nlaongtup.github.io/post/scipy-lammps/</link>
      <pubDate>Sun, 06 Oct 2019 00:03:00 +0000</pubDate>
      <guid>https://nlaongtup.github.io/post/scipy-lammps/</guid>
      <description>

&lt;p&gt;Making a kinetics Monte Carlo platform using SciPy and LAMMP.&lt;/p&gt;

&lt;h2 id=&#34;example-output&#34;&gt;Example output&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;KMC step 1
ABC step 1 displacement = 0.227
ABC step 2 displacement = 1.432
ABC step 3 displacement = 1.702
ABC step 4 displacement = 1.855
ABC step 5 displacement = 1.976
ABC step 6 displacement = 2.600
ABC step 6 displacement = 2.600 (without penalty functions)
NEB calculation Begin
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:15:04     -478.527190        0.7884
BFGSLineSearch:    1[  2] 22:15:08     -478.713136        0.1264
BFGSLineSearch:    2[  3] 22:15:10     -478.736565        0.0476
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:15:11     -478.655201        0.0940
BFGSLineSearch:    1[  1] 22:15:13     -478.656759        0.0389
      Step     Time          Energy         fmax
BFGS:    0 22:15:22     -476.953036        2.6077
BFGS:    1 22:15:27     -477.252710        1.8046
BFGS:    2 22:15:33     -477.476933        1.0780
BFGS:    3 22:15:38     -477.607836        0.5111
BFGS:    4 22:15:43     -477.664734        0.3071
BFGS:    5 22:15:49     -477.681873        0.3395
BFGS:    6 22:15:54     -477.706804        0.3279
BFGS:    7 22:16:00     -477.723018        0.1892
BFGS:    8 22:16:05     -477.731365        0.1241
BFGS:    9 22:16:11     -477.736875        0.1239
BFGS:   10 22:16:16     -477.742986        0.1539
BFGS:   11 22:16:21     -477.748930        0.1101
BFGS:   12 22:16:27     -477.751942        0.0808
NEB calculation Finished
Barrier= 0.9846223063690331
Found neighbor state no. 1
ABC+NEB calculation time: 244.7346179485321

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./03_KMC-test_working_25_6.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;import-lib&#34;&gt;Import lib&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from lammps import lammps
import numpy as np
from scipy.optimize import minimize
from ase.io import read, write
from ase import Atoms
from copy import deepcopy
from numpy import linalg as LA
import itertools
import matplotlib.pyplot as plt
import time

from ase.calculators.eam import EAM
from ase.neb import SingleCalculatorNEB
from ase.neb import NEBTools
from ase.optimize import BFGS
from ase.optimize import QuasiNewton
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initiate-lammps-environment&#34;&gt;Initiate LAMMPS environment&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# lmp = lammps() #normal initialize LAMMPS
lmp = lammps(cmdargs=[&amp;quot;-screen&amp;quot;,&amp;quot;none&amp;quot;]) #turn off screen output
lmp.file(&amp;quot;etc/config.in.107&amp;quot;)
natoms = lmp.get_natoms()
boxlo,boxhi,xy,yz,xz,periodicity,box_change = lmp.extract_box()
cubic_size = boxhi[0]-boxlo[0]

#Set potential energy calculation
lmp.command(&amp;quot;compute 1 all pe&amp;quot;)
lmp.command(&amp;quot;variable pe equal pe&amp;quot;)

#calculate potenEn
lmp.command(&amp;quot;run 0 pre no post no&amp;quot;)
potenEn = lmp.extract_variable(&#39;pe&#39;,&#39;all&#39;,0)

x = lmp.gather_atoms(&amp;quot;x&amp;quot;,1,3) #Define the type of variable &amp;quot;x&amp;quot; as lammps.c_double_Array_93 object
enable_penalty = True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;extract-python-array-of-coordinates-form-lammps&#34;&gt;Extract Python array of coordinates form LAMMPS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;coords = lmp.gather_atoms(&amp;quot;x&amp;quot;,1,3)
import_position = list(zip(*(iter(list(coords)),) * 3))


#LAMMPS atom type: 1=Ni, 2=Al, 3=Re
atom_type = []
atom_type_lammps = lmp.gather_atoms(&amp;quot;type&amp;quot;,0,1)
for i in range(natoms):
    if(atom_type_lammps[i]==1):
        atom_type.append(&amp;quot;Ni&amp;quot;)
    elif(atom_type_lammps[i]==2):
        atom_type.append(&amp;quot;Al&amp;quot;)
    else:
        atom_type.append(&amp;quot;Re&amp;quot;)      

#LAMMPS atom order
atom_order = []
for i in range(len(import_position)):
    atom_order.append(i)
atom_order = np.array(atom_order)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dump-function&#34;&gt;Dump function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dump(atomic_position, filename):

    element = atom_type
    structure =Atoms(element,
                     positions=atomic_position)

    #wrap positions to unit cell
    structure.set_cell((boxhi[0]-boxlo[0]) * np.identity(3))
    structure.set_pbc((True, True, True))
    structure.wrap(eps=0.1)

    structure.write(filename, append=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lammps-energy-function&#34;&gt;LAMMPS energy function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Plain array without dimensions

def get_poten(atomic_position):

    for i in range(len(atomic_position)):
         x[i] = atomic_position[i]

    lmp.scatter_atoms(&amp;quot;x&amp;quot;,1,3,x)
    lmp.command(&amp;quot;run 0 pre yes post no&amp;quot;)
    potenEn = lmp.extract_variable(&#39;pe&#39;,&#39;all&#39;,0)
    return potenEn
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;gaussain-energy-function&#34;&gt;Gaussain energy function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# dimension list

gaussian_list = []
sigma_gauss = 1.0 #Sigma square
a_gauss = 1.0 #W

def get_gauss(atomic_position_flat):
    atomic_position = list(zip(*(iter(list(atomic_position_flat)),) * 3))
    gaussianEn =0;

    for each_gaussian in gaussian_list:
        power_part=0;
        for index in range(len(atomic_position)):
            for variable in range(3):

                #map new order of gaussian variables accordding to optimization wrapper function, important!
                atom_id = atom_order[index]



                power_part = power_part - np.square(atomic_position[index][variable] - each_gaussian[atom_id][variable])

        power_part = power_part / (2*sigma_gauss)
        gaussianEn = gaussianEn + a_gauss*np.exp(power_part)
    return gaussianEn
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scipy-optimization-wrapper&#34;&gt;SciPy optimization wrapper&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Optimization function wrapper
#A lot of dimension fix has to be done before in here

def optimize_wrapper(atomic_position):

    global atom_type
    global atom_type_lammps
    global atom_order

    atom_type_ori = deepcopy(atom_type)

    #create numpy array of atomic_position
    atomic_position = np.array(atomic_position)

    #gather element type data from LAMMPS and add into the array
    atom_type_lammps = lmp.gather_atoms(&amp;quot;type&amp;quot;,0,1)
    atom_type_lammps_nparray = np.array(atom_type_lammps)
    atomic_position =  np.column_stack((atomic_position, atom_type_lammps_nparray))


    #add atom order array for mapping gaussian variables and sorting all atoms after finish optimization
    atomic_position =  np.column_stack((atomic_position, atom_order))


    #separate optimizing atoms and fix atoms by y-position = 0.5 (fix atoms from the first plane to facilitate ABC method)
    fix_atom = atomic_position[atomic_position[:,1] &amp;lt; 0.5]
    fix_atom_list = fix_atom.tolist()
    opt_atom = atomic_position[atomic_position[:,1] &amp;gt; 0.5]
    opt_atom_list = opt_atom.tolist()
    all_atom = fix_atom_list + opt_atom_list


    #update new atom order
    for i in range(natoms):
        atom_order[i] = int(all_atom[i][4])

    #update new order of element type to atom_type array
    for i in range(natoms):
        if(all_atom[i][3]==1):
                atom_type[i]=&amp;quot;Ni&amp;quot;
        elif(all_atom[i][3]==2):
            atom_type[i]=&amp;quot;Al&amp;quot;
        else:
            atom_type[i]=&amp;quot;Re&amp;quot;

    #update new order of element type to LAMMPS
    for i in range(natoms):
        atom_type_lammps[i] = int(all_atom[i][3])
    lmp.scatter_atoms(&amp;quot;type&amp;quot;,0,1,atom_type_lammps)

    #map new order of gaussian variables accordding to the new atom order, important!

    #extract only coordinate from the array to be sent to SciPy optimizer
    fix_atom = fix_atom[:,[0,1,2]]
    opt_atom = opt_atom[:,[0,1,2]]

    #call back function for mornitoring optimization progress
    callback_itter = 1
    def callbackF(Xi):
        global callback_itter


        optimizing_atom_tuple = list(zip(*(iter(list(Xi)),) * 3))
        optimizing_atom = np.array(optimizing_atom_tuple)

        fix_atom_array = np.array(fix_atom)

        dump_position = np.concatenate((fix_atom_array,optimizing_atom),axis=0)

        dump(dump_position,&amp;quot;opt_traj.xyz&amp;quot;)
        callback_itter += 1;

    def objective_func(optimizing_atom, args) :

        fix_atom = args.get(&amp;quot;fixed_atom&amp;quot;)
        fix_atom = list(itertools.chain.from_iterable(fix_atom))

        atomic_position = list(fix_atom) + list(optimizing_atom)
        poten_en =  get_poten(atomic_position)

        if(enable_penalty==True):
            penalty_en = get_gauss(atomic_position)
        else:
            penalty_en = 0.0

        total_en = poten_en + penalty_en
        return total_en

    optimization_result = minimize(objective_func,
                                   x0 = opt_atom,
                                   args = {&amp;quot;fixed_atom&amp;quot;:fix_atom},
                                   method=&#39;BFGS&#39;,
                                   callback=callbackF,
                                   options={&#39;gtol&#39;:1e-2,&#39;maxiter&#39;: None, &#39;disp&#39;: False}
                                  )

    #combine optimizing atom and fix atom into atomic_position
    optimizing_atom = optimization_result.x
    optimizing_atom= list(zip(*(iter(list(optimizing_atom)),) * 3))
    optimizing_atom = np.array(optimizing_atom)
    atomic_position = np.concatenate((fix_atom,optimizing_atom),axis=0)

    #combine atomic_position atom_order, sort by atom order (important step for checking total displacment)
    combine_array = np.column_stack((atomic_position, atom_order))
    combine_array = combine_array[combine_array[:,3].argsort()]
    atomic_position = combine_array[:,[0,1,2]]

    #rollback old atom type order
    atom_type = atom_type_ori

    #rollback old atom type order for LAMMPS
    for i in range(natoms):
        if(atom_type[i]==&amp;quot;Ni&amp;quot;):
            atom_type_lammps[i] =1
        elif(atom_type[i]==&amp;quot;Al&amp;quot;):
            atom_type_lammps[i]=2
        else:
            atom_type_lammps[i]=3
    lmp.scatter_atoms(&amp;quot;type&amp;quot;,0,1,atom_type_lammps)

    #sort atom_order back to originol value
    atom_order = atom_order[atom_order.argsort()]

    optimization_result.x = atomic_position
    return optimization_result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;neb-wrapper&#34;&gt;NEB wrapper&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class NEB:

    def __init__(self, initial, final, n_image=5):

        self.initial = initial
        self.final = final
        self.transition_stat = None
        self.barrier = None
        self.n_image = n_image

    def run(self):

        print(&amp;quot;NEB calculation Begin&amp;quot;)

        initial_image =Atoms(atom_type, positions=current_pos)
        final_image =Atoms(atom_type, positions=new_state)

        initial_image.set_cell((boxhi[0]-boxlo[0]) * np.identity(3))
        initial_image.set_pbc((True, True, True))
        final_image.set_cell((boxhi[0]-boxlo[0]) * np.identity(3))
        final_image.set_pbc((True, True, True))

        NiAlRe_EAM = EAM(potential=&#39;etc/NiAlRe.eam.alloy&#39;)

        # Relaxation before NEB
        initial_image.set_calculator(NiAlRe_EAM)
        qn = QuasiNewton(initial_image)
        qn.run(fmax=0.05)
        final_image.set_calculator(NiAlRe_EAM)
        qn = QuasiNewton(final_image)
        qn.run(fmax=0.05)

        images = [initial_image]
        for i in range(self.n_image-2):
            image = initial_image.copy()
            image.set_calculator(NiAlRe_EAM)
            images.append(image)

        images.append(final_image)
        neb = SingleCalculatorNEB(images)
        neb.interpolate()
        bfgs = BFGS(neb)
        bfgs.run(fmax=0.1)

        for item in images:
            item.set_calculator(NiAlRe_EAM)
        nebtools = NEBTools(images)

        print(&amp;quot;NEB calculation Finished&amp;quot;)

        # Create a figure with custom parameters.
        fig = plt.figure(figsize=(5.5, 4.0))
        ax = fig.add_axes((0.15, 0.15, 0.8, 0.75))
        nebtools.plot_band(ax)
        fig.savefig(&#39;latest_neb.png&#39;)

        #neb output: transition_state, barrier
        self.transition_state = images[int((self.n_image-1)/2)].positions #Can be fixed as highest energy imagee
        self.barrier,dE= nebtools.get_barrier(fit=False)

        output = {
            &amp;quot;transition_state&amp;quot;: self.transition_state ,
            &amp;quot;barrier&amp;quot;: self.barrier
        }
        return output
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clear-old-files&#34;&gt;clear old files&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# clear old files
import os
file_name = [&amp;quot;opt_traj.xyz&amp;quot;, &amp;quot;neighbor_state.xyz&amp;quot;, &amp;quot;abc_step.xyz&amp;quot;, &amp;quot;transition_state.xyz&amp;quot;,&amp;quot;log.lammps&amp;quot;,&amp;quot;latest_neb.png&amp;quot;]
for filename in file_name:
    try:
        os.remove(filename)
    except OSError:
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;current_pos = deepcopy(import_position)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kmc-step&#34;&gt;KMC Step&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for kmc_step in range(1,10): #KMC step

    kmc_start_time = time.time()
    print(&amp;quot;KMC step&amp;quot;, kmc_step)

    #restart ABC variables
    n_neighbor = 0
    neighbor_state = []
    transition_state_list = []
    barrier_list = []
    gaussian_list = []
    just_added = False

    for i in range(50): #ABC step

        abc_start_time = time.time()               

        if(just_added == True):
            #just added from transition state, skip 1 time
            just_added = False
        else:
            #Add gaussian at the current state also
            temp_list = deepcopy(current_pos)
            gaussian_list.append(temp_list)

        #optimization
        callback_itter = 1
        enable_penalty = True
        optimization_result = optimize_wrapper(current_pos)

        #check displacment
        relaxed_position = optimization_result.x
        relaxed_position = np.array(relaxed_position)
        current_pos = np.array(current_pos)

        difference_pos = np.round(relaxed_position - current_pos,2)
        displacement = LA.norm(difference_pos)
        print(&amp;quot;ABC step {0} displacement = {1:5.3f}&amp;quot;.format(i+1, displacement))
        dump(relaxed_position,&amp;quot;abc_step.xyz&amp;quot;)

        #found new state
        if(displacement &amp;gt;= 2.5):

            #Improvement point: Check that it not the old neighbor state that has been found before
            #disable all penalty Gassian functions
            enable_penalty = False
            new_state = deepcopy(relaxed_position)
            optimization_result = optimize_wrapper(new_state)
            new_state = np.array(optimization_result.x)

            #check displacment again
            relaxed_position = optimization_result.x
            relaxed_position = np.array(relaxed_position)
            current_pos = np.array(current_pos)

            print(&amp;quot;ABC step {0} displacement = {1:5.3f} (without penalty functions)&amp;quot;.format(i+1, displacement))

            if(displacement &amp;gt;= 2.5):
                #neb
                neb_object = NEB(current_pos,new_state)
                neb_result = neb_object.run()
                barrier = neb_result[&amp;quot;barrier&amp;quot;]
                transition_state = neb_result[&amp;quot;transition_state&amp;quot;]
                print(&amp;quot;Barrier=&amp;quot;,barrier)

                if(barrier&amp;gt;0.1):
                    n_neighbor +=1
                    print(&amp;quot;Found neighbor state no. {0}&amp;quot;.format(n_neighbor))
                    dump(relaxed_position,&amp;quot;neighbor_state.xyz&amp;quot;)
                    neighbor_state.append(new_state)
                    barrier_list.append(barrier)
                    transition_state_list.append(transition_state)
                    dump(transition_state,&amp;quot;transition_state.xyz&amp;quot;)

                    #Add gaussian at the transition state
                    temp_list = deepcopy(transition_state)
                    gaussian_list.append(temp_list)
                    just_added = True
                    abc_end_time = time.time()
                    print(&amp;quot;ABC+NEB calculation time:&amp;quot;,abc_end_time - abc_start_time)
                else:
                    print(&amp;quot;Too small barrier, continue searching&amp;quot;.format(i+1, displacement))

            else:
                print(&amp;quot;Too small displacement, continue searching&amp;quot;.format(i+1, displacement))


        if(n_neighbor&amp;gt;=6): #how many nearest neighbor states to search
            rand_int = np.random.randint(n_neighbor)
            chosen_state = deepcopy(neighbor_state[rand_int])

            #wrap positions to unit cell
            ase_temp =Atoms(atom_type, positions=chosen_state)
            ase_temp.set_cell((boxhi[0]-boxlo[0]) * np.identity(3))
            ase_temp.set_pbc((True, True, True))
            ase_temp.wrap(eps=0.1)
            current_pos = ase_temp.positions

            #break a symetry
            current_pos = np.array(current_pos)
            for i in range(len(current_pos)):
                current_pos[i] = current_pos[i] + np.random.uniform(low=-0.1,high=0.1) #only from -0.1 to 0.1

            kmc_end_time = time.time()
            print(&amp;quot;KMC calculation time:&amp;quot;,kmc_end_time - kmc_start_time)

            break

    #calculate KMC time and next state
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;KMC step 1
ABC step 1 displacement = 0.227
ABC step 2 displacement = 1.432
ABC step 3 displacement = 1.702
ABC step 4 displacement = 1.855
ABC step 5 displacement = 1.976
ABC step 6 displacement = 2.600
ABC step 6 displacement = 2.600 (without penalty functions)
NEB calculation Begin
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:15:04     -478.527190        0.7884
BFGSLineSearch:    1[  2] 22:15:08     -478.713136        0.1264
BFGSLineSearch:    2[  3] 22:15:10     -478.736565        0.0476
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:15:11     -478.655201        0.0940
BFGSLineSearch:    1[  1] 22:15:13     -478.656759        0.0389
      Step     Time          Energy         fmax
BFGS:    0 22:15:22     -476.953036        2.6077
BFGS:    1 22:15:27     -477.252710        1.8046
BFGS:    2 22:15:33     -477.476933        1.0780
BFGS:    3 22:15:38     -477.607836        0.5111
BFGS:    4 22:15:43     -477.664734        0.3071
BFGS:    5 22:15:49     -477.681873        0.3395
BFGS:    6 22:15:54     -477.706804        0.3279
BFGS:    7 22:16:00     -477.723018        0.1892
BFGS:    8 22:16:05     -477.731365        0.1241
BFGS:    9 22:16:11     -477.736875        0.1239
BFGS:   10 22:16:16     -477.742986        0.1539
BFGS:   11 22:16:21     -477.748930        0.1101
BFGS:   12 22:16:27     -477.751942        0.0808
NEB calculation Finished
Barrier= 0.9846223063690331
Found neighbor state no. 1
ABC+NEB calculation time: 244.7346179485321
ABC step 7 displacement = 2.609
ABC step 7 displacement = 2.609 (without penalty functions)
NEB calculation Begin
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:19:22     -478.527190        0.7884
BFGSLineSearch:    1[  2] 22:19:26     -478.713136        0.1264
BFGSLineSearch:    2[  3] 22:19:28     -478.736565        0.0476
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:19:29     -478.654947        0.0977
BFGSLineSearch:    1[  1] 22:19:31     -478.656831        0.0382
      Step     Time          Energy         fmax
BFGS:    0 22:19:40     -476.959569        2.5796
BFGS:    1 22:19:45     -477.256307        1.8014
BFGS:    2 22:19:51     -477.479227        1.0754
BFGS:    3 22:19:56     -477.609406        0.5077
BFGS:    4 22:20:02     -477.665905        0.3056
BFGS:    5 22:20:07     -477.682894        0.3372
BFGS:    6 22:20:12     -477.707776        0.3255
BFGS:    7 22:20:18     -477.723833        0.1877
BFGS:    8 22:20:23     -477.732082        0.1233
BFGS:    9 22:20:29     -477.737522        0.1230
BFGS:   10 22:20:34     -477.743555        0.1520
BFGS:   11 22:20:40     -477.749361        0.1076
BFGS:   12 22:20:45     -477.752265        0.0795
NEB calculation Finished
Barrier= 0.9842993137219764
Found neighbor state no. 2
ABC+NEB calculation time: 258.14030027389526
ABC step 8 displacement = 2.606
ABC step 8 displacement = 2.606 (without penalty functions)
NEB calculation Begin
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:23:24     -478.527190        0.7884
BFGSLineSearch:    1[  2] 22:23:27     -478.713136        0.1264
BFGSLineSearch:    2[  3] 22:23:29     -478.736565        0.0476
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:23:31     -478.689449        0.0562
BFGSLineSearch:    1[  1] 22:23:33     -478.689966        0.0296
      Step     Time          Energy         fmax
BFGS:    0 22:23:41     -476.851140        2.6717
BFGS:    1 22:23:46     -477.174961        1.8294
BFGS:    2 22:23:52     -477.412534        1.0818
BFGS:    3 22:23:57     -477.551579        0.4508
BFGS:    4 22:24:03     -477.610318        0.2998
BFGS:    5 22:24:08     -477.626811        0.2685
BFGS:    6 22:24:13     -477.650855        0.2785
BFGS:    7 22:24:19     -477.665956        0.1621
BFGS:    8 22:24:24     -477.673461        0.1109
BFGS:    9 22:24:29     -477.678515        0.1209
BFGS:   10 22:24:34     -477.684294        0.1472
BFGS:   11 22:24:40     -477.689896        0.1028
BFGS:   12 22:24:45     -477.692716        0.0740
NEB calculation Finished
Barrier= 1.0438484267736499
Found neighbor state no. 3
ABC+NEB calculation time: 240.14303255081177
ABC step 9 displacement = 2.158
ABC step 10 displacement = 2.209
ABC step 11 displacement = 2.270
ABC step 12 displacement = 2.310
ABC step 13 displacement = 2.361
ABC step 14 displacement = 2.391
ABC step 15 displacement = 2.416
ABC step 16 displacement = 2.456
ABC step 17 displacement = 2.487
ABC step 18 displacement = 2.798
ABC step 18 displacement = 2.798 (without penalty functions)
NEB calculation Begin
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:57:37     -478.527190        0.7884
BFGSLineSearch:    1[  2] 22:57:41     -478.713136        0.1264
BFGSLineSearch:    2[  3] 22:57:42     -478.736565        0.0476
                Step[ FC]     Time          Energy          fmax
BFGSLineSearch:    0[  0] 22:57:44     -478.655119        0.0943
BFGSLineSearch:    1[  1] 22:57:46     -478.656641        0.0406
      Step     Time          Energy         fmax
BFGS:    0 22:57:54     -476.956730        2.6010
BFGS:    1 22:58:00     -477.255083        1.8011
BFGS:    2 22:58:05     -477.478776        1.0750
BFGS:    3 22:58:11     -477.609177        0.5084
BFGS:    4 22:58:16     -477.665627        0.3071
BFGS:    5 22:58:21     -477.682608        0.3385
BFGS:    6 22:58:27     -477.707672        0.3252
BFGS:    7 22:58:32     -477.723603        0.1865
BFGS:    8 22:58:38     -477.731819        0.1241
BFGS:    9 22:58:43     -477.737271        0.1232
BFGS:   10 22:58:49     -477.743364        0.1531
BFGS:   11 22:58:54     -477.749219        0.1082
BFGS:   12 22:58:59     -477.752158        0.0804
NEB calculation Finished
Barrier= 0.9844069686880061
Found neighbor state no. 4
ABC+NEB calculation time: 457.05262541770935
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./03_KMC-test_working_25_4.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./03_KMC-test_working_25_5.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./03_KMC-test_working_25_6.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
